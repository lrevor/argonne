C This subroutine accepts a given probe as input, and expands to every
C  possible combination with the given table of data.  It simulates a
C  recursive call sequentially.

      SUBROUTINE NEXT(POSIT, PLEN, PNUM, PLIST, NEXT_POS)

C POSIT = INTIAL PROBE ; FPOS = FRAGMENT USED ; PLEN = LENGTH OF PROBES
C TAB = 2D ARRAY HOLDING THE DATA (LOGICAL) ; PNUM = THE # OF PROBES
C FMAX = THE MAX. # OF FRAGMENTS

      INTEGER POSIT, EXT_LEN, PLEN, PNUM, PLIST(0:PNUM)
      INTEGER NEXT_POS(0:PNUM)
      INTEGER SUM(50), MASK, NEWPOS
      INTEGER POS_VEC(0:50)

C EXT_LEN = LENGTH OF CURRENT EXTENSION ; SUM = ACCUMULATORS FOR KEEPING
C  TRACK OF # OF DISTINCT FRAGMENTS ; MASK = BIT PATTERN TO ZERO LEFT BITS
C POS_VEC = STACK FOR KEEPING TRACK OF PROBES IN EXTENSION
C NEWPOS = STACK FOR FIRST (OF 4) POSSIBLE EXTENSION FRAGMENT (NEEDED FOR
C  KNOWING WHEN WE HAVE CHECKED ALL 4 POSSIBILITIES.)

      COMMON SUM

      MASK=3
      NEWPOS=POSIT
      EXT_LEN=PLEN-1
  10  EXT_LEN=EXT_LEN+1

      SUM(EXT_LEN)=SUM(EXT_LEN)+1

      POS_VEC(EXT_LEN)=NEWPOS
      IF (EXT_LEN.GE.30) GO TO 40
      NEWPOS=NEXT_POS(NEWPOS)
      
  20  IF (PLIST(NEWPOS).EQ.1) GO TO 10

  30  NEWPOS=NEWPOS+1
      IF ((NEWPOS.AND.MASK).NE.0) GO TO 20

  40  NEWPOS=POS_VEC(EXT_LEN)
      EXT_LEN=EXT_LEN-1

      IF (EXT_LEN.GE.PLEN) GO TO 30

      RETURN
      END
