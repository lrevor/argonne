C This subroutine accepts a given probe as input, and expands to every
C  possible combination with the given table of data.  It simulates a
C  recursive call sequentially.

      SUBROUTINE NEXT(POSIT, PLEN, PNUM, PLIST, NEXT_POS)

C POSIT = INTIAL PROBE ; FPOS = FRAGMENT USED ; PLEN = LENGTH OF PROBES
C TAB = 2D ARRAY HOLDING THE DATA (LOGICAL) ; PNUM = THE # OF PROBES
C FMAX = THE MAX. # OF FRAGMENTS

      INTEGER POSIT, EXT_LEN, PLEN, PNUM, PLIST(0:PNUM)
      INTEGER NEXT_POS(0:PNUM)
      INTEGER SUM(30), MASK, NEWPOS
      INTEGER POS_VEC(0:50)
      LOGICAL FALLBACK

C EXT_LEN = LENGTH OF CURRENT EXTENSION ; SUM = ACCUMULATORS FOR KEEPING
C  TRACK OF # OF DISTINCT FRAGMENTS ; MASK = BIT PATTERN TO ZERO LEFT BITS
C POS_VEC = STACK FOR KEEPING TRACK OF PROBES IN EXTENSION
C NEWPOS = STACK FOR FIRST (OF 4) POSSIBLE EXTENSION FRAGMENT (NEEDED FOR
C  KNOWING WHEN WE HAVE CHECKED ALL 4 POSSIBILITIES.)

      COMMON SUM

      MASK=3
      EXT_LEN=PLEN
      NEWPOS=POSIT
      POS_VEC(PLEN)=NEWPOS

      NEWPOS=NEXT_POS(NEWPOS)
      EXT_LEN=EXT_LEN+1
      FALLBACK=.FALSE.

      DO 10 WHILE (EXT_LEN.GT.PLEN)
        IF (PLIST(NEWPOS).EQ.1) THEN
          SUM(EXT_LEN)=SUM(EXT_LEN)+1
          POS_VEC(EXT_LEN)=NEWPOS
          EXT_LEN=EXT_LEN+1
          NEWPOS=NEXT_POS(NEWPOS)
         ELSE
          NEWPOS=NEWPOS+1
          IF ((NEWPOS.AND.MASK).EQ.0) FALLBACK=.TRUE.
        END IF

        IF ((EXT_LEN.GE.31).OR.FALLBACK) THEN
          EXT_LEN=EXT_LEN-1
          NEWPOS=POS_VEC(EXT_LEN)+1
          FALLBACK=.FALSE.
          DO 20 WHILE ((NEWPOS.AND.MASK).EQ.0)
            EXT_LEN=EXT_LEN-1
            NEWPOS=POS_VEC(EXT_LEN)+1
  20      CONTINUE
        END IF
  10  CONTINUE

      RETURN
      END
