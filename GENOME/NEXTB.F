C This subroutine accepts a given probe as input, and expands to every
C  possible combination with the given table of data.  It simulates a
C  recursive call sequentially.

      SUBROUTINE NEXT(POSIT, PLEN, PNUM, PLIST)

C POSIT = INTIAL PROBE ; FPOS = FRAGMENT USED ; PLEN = LENGTH OF PROBES
C TAB = 2D ARRAY HOLDING THE DATA (LOGICAL) ; PNUM = THE # OF PROBES
C FMAX = THE MAX. # OF FRAGMENTS

      INTEGER POSIT, EXT_LEN, PLEN, PNUM, PLIST(0:PNUM)
      INTEGER SUM(5), MASK, LOOP
      INTEGER POS_VEC(0:50), NEWPOS(0:50)

C EXT_LEN = LENGTH OF CURRENT EXTENSION ; SUM = ACCUMULATORS FOR KEEPING
C  TRACK OF # OF DISTINCT FRAGMENTS ; MASK = BIT PATTERN TO ZERO LEFT BITS
C POS_VEC = STACK FOR KEEPING TRACK OF PROBES IN EXTENSION
C NEWPOS = STACK FOR FIRST (OF 4) POSSIBLE EXTENSION FRAGMENT (NEEDED FOR
C  KNOWING WHEN WE HAVE CHECKED ALL 4 POSSIBILITIES.)

      COMMON SUM

C INITIALIZE POS_VEC STACK, SET INITIAL EXTENSION LENGTH, SET MASK VALUE

      POS_VEC(PLEN) = POSIT
      EXT_LEN = PLEN
      MASK = 4**(PLEN-1)-1

C IF THE LENGTH OF EXTENSION = 50 THEN ADD 1 TO ACCUMULATER AND DO NOT LOOK
C  FOR POSSIBLE EXTENSIONS.  IF EXT_LEN <50 THEN LOOK.

  10  IF (EXT_LEN .GE. 50) THEN
        SUM(5) = SUM(5) + 1
       ELSE

C ADD TO APPROPRIATE ACCUMULATER IF LENGTH IS OF SPECIFIED VALUE.
        DO 100 LOOP = 1,5
          IF (EXT_LEN .EQ. (LOOP*10)) SUM(LOOP) = SUM(LOOP) + 1
  100    CONTINUE

C FIND FIRST POSSIBLE EXTENSION TO CURRENT PROBE
        NEWPOS(EXT_LEN) = POS_VEC(EXT_LEN).AND.MASK
        NEWPOS(EXT_LEN) = NEWPOS(EXT_LEN)*4

C INCREMENT LENGTH AND CHECK TO SEE IF THE POSSIBLE EXTENSIONS ARE IN THE
C TABLE.  IF THEY ARE, JUMP TO BEGINING OF ROUTINE (THIS SIMULATES THE
C RECURSIVE CALL.  THE LINE AFTER 120 CHECKS TO SEE IF WE HAVE CHECK ALL
C POSSIBLE EXTENSIONS.  IF NOT, BRANCH BACK TO 110 TO CHECK THE NEXT.  IF
C WE HAVE CHECKED ALL EXTENSIONS, THEN FALL BACK ONE IN THE STACK.

        EXT_LEN = EXT_LEN + 1
        POS_VEC(EXT_LEN) = NEWPOS(EXT_LEN-1)
  110   IF ( PLIST( POS_VEC(EXT_LEN) ) .EQ. 1) GO TO 10
  120   POS_VEC(EXT_LEN) = POS_VEC(EXT_LEN) + 1
        IF (POS_VEC(EXT_LEN) .LE. (NEWPOS(EXT_LEN-1)+3)) GO TO 110
        
        EXT_LEN = EXT_LEN - 1
       END IF

C THE ABOVE LOOP HANDLES THE FORWARD BRANCHING.  THIS NEXT LINE ALLOWS US
C TO FALL BACK ONE IN THE STACK, AND BEGIN BUILDING WHERE WE LEFT OFF.  IF
C THE EXT_LEN IS EQUAL TO THE PLEN, THEN WE HAVE GONE THROUGH ALL POSSIBLE
C COMBINATIONS AND WE SHOULD FINISH THE ROUTINE.

      IF (EXT_LEN .GT. PLEN) GO TO 120

      RETURN
      END
